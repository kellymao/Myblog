<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mao</title>
    <description>欢迎来到我的个人站~</description>
    <link>http://0.0.0.0:9000/</link>
    <atom:link href="http://0.0.0.0:9000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 06 Sep 2019 13:21:24 +0800</pubDate>
    <lastBuildDate>Fri, 06 Sep 2019 13:21:24 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Go语言反射（reflection）简述</title>
        <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;反射的基本概念&quot;&gt;反射的基本概念&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Go语言中的反射与其他语言有比较大的不同。首先我们要理解两个基本概念 Type 和 Value，它们也是 Go语言包中 reflect 空间里最重要的两个类型。我们先看一下下面的定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type MyReader struct {
	Name string
}
func (r MyReader)Read(p []byte) (n int, err error) {
	// 实现自己的Read方法
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为 MyReader 类型实现了 io.Reader 接口的所有方法（其实就是一个 Read() 函数），所以 MyReader 实现了接口 io.Reader。我们可以按如下方式来进行 MyReader 的实例化和赋值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var reader io.Reader
reader = &amp;amp;MyReader{&quot;a.txt&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在我们可以再来解释一下什么是 Type，什么是 Value。&lt;/p&gt;

&lt;p&gt;对所有接口进行反射，都可以得到一个包含 Type 和 Value 的信息结构。比如我们对上例的 reader 进行反射，也将得到一个 Type 和 Value，Type 为 io.Reader，Value 为 MyReader{“a.txt”}。顾名思义，Type 主要表达的是被反射的这个变量本身的类型信息，而 Value 则为该变量实例本身的信息。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;反射规则浅析&quot;&gt;反射规则浅析&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;前面讲解了 Value 和 Type 的基本概念，本节重点讲解反射对象 Value、Type 和类型实例之间的相互转化。实例、Value、Type 三者之间的转换关系如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://c.biancheng.net/uploads/allimg/190813/4-1ZQ31336163P.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;反射-api-的分类总结如下&quot;&gt;&lt;strong&gt;反射 API 的分类总结如下:&lt;/strong&gt;&lt;/h5&gt;

&lt;h5 id=&quot;1-通过实例获取-value-对象直接使用-reflectvalueof-函数&quot;&gt;&lt;strong&gt;1. 通过实例获取 Value 对象，直接使用 reflect.ValueOf() 函数&lt;/strong&gt;&lt;/h5&gt;

&lt;h5 id=&quot;2-通过实例获取反射对象的-type直接使用-reflecttypeof-函数&quot;&gt;&lt;strong&gt;2. 通过实例获取反射对象的 Type，直接使用 reflect.TypeOf() 函数&lt;/strong&gt;&lt;/h5&gt;

&lt;h5 id=&quot;3-从-value-获取反射对象的-type可以直接调用-valuetype方法因为-value-内部存放着到-type-类型的指针&quot;&gt;&lt;strong&gt;3. 从 Value 获取反射对象的 Type，可以直接调用 Value.Type()方法，因为 Value 内部存放着到 Type 类型的指针&lt;/strong&gt;&lt;/h5&gt;

&lt;h5 id=&quot;4-value-到实例的转换value-本身就包含类型和值信息reflect-提供了丰富的方法来实现从-value-到实例的转换&quot;&gt;&lt;strong&gt;4. Value 到实例的转换，Value 本身就包含类型和值信息，reflect 提供了丰富的方法来实现从 Value 到实例的转换&lt;/strong&gt;&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//该方法最通用，用来将 Value 转换为空接口，该空接口内部存放具体类型实例

func (v Value) Interface() （i interface{})

//Value 自身也提供丰富的方法，直接将 Value 转换为简单类型实例，如果类型不匹配，则直接引起 panic

func (v Value) Bool () bool
func (v Value) Float() float64
func (v Value) Int() int64
func (v Value) Uint() uint64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;5-从一个指针类型的-value-获得值类型-value-直接调用-elem-方法&quot;&gt;&lt;strong&gt;5. 从一个指针类型的 Value 获得值类型 Value， 直接调用 Elem() 方法&lt;/strong&gt;&lt;/h5&gt;

&lt;h5 id=&quot;6-从一个指针类型的-type-获得值类型-type-也是直接调用-elem-方法&quot;&gt;&lt;strong&gt;6. 从一个指针类型的 Type 获得值类型 Type ，也是直接调用 Elem() 方法&lt;/strong&gt;&lt;/h5&gt;

&lt;h5 id=&quot;7-判断value-值的可修改性-canset-方法修改value的值--setx-value-方法&quot;&gt;&lt;strong&gt;7. 判断Value 值的可修改性 CanSet() 方法，修改value的值  Set(x Value) 方法&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;理解反射的类型type与种类kind&quot;&gt;理解反射的类型（Type）与种类（Kind）&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-反射种类kind的定义&quot;&gt;1) 反射种类（Kind）的定义&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：

type Kind uint
const (
	Invalid Kind = iota  // 非法类型
	Bool                 // 布尔型
	Int                  // 有符号整型
	Int8                 // 有符号8位整型
	Int16                // 有符号16位整型
	Int32                // 有符号32位整型
	Int64                // 有符号64位整型
	Uint                 // 无符号整型
	Uint8                // 无符号8位整型
	Uint16               // 无符号16位整型
	Uint32               // 无符号32位整型
	Uint64               // 无符号64位整型
	Uintptr              // 指针
	Float32              // 单精度浮点数
	Float64              // 双精度浮点数
	Complex64            // 64位复数类型
	Complex128           // 128位复数类型
	Array                // 数组
	Chan                 // 通道
	Func                 // 函数
	Interface            // 接口
	Map                  // 映射
	Ptr                  // 指针
	Slice                // 切片
	String               // 字符串
	Struct               // 结构体
	UnsafePointer        // 底层指针
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-类型type的定义&quot;&gt;2) 类型（Type）的定义&lt;/h3&gt;

&lt;p&gt;Go 程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。&lt;/p&gt;

&lt;h2 id=&quot;go语言通过反射获取-type-的相关方法&quot;&gt;Go语言通过反射获取 Type 的相关方法&lt;/h2&gt;

&lt;h3 id=&quot;基本的方法&quot;&gt;基本的方法：&lt;/h3&gt;

&lt;p&gt;t_ptr := reflect.TypeOf(&amp;amp;a)  获取反射对象的 Type&lt;/p&gt;

&lt;p&gt;t := t_ptr.Elem() 从指针获取值 ，得到reflect.Type 对象&lt;/p&gt;

&lt;p&gt;t.Name()  返回的是类型&lt;/p&gt;

&lt;p&gt;t.Kind()  返回是种类，const定义的常量&lt;/p&gt;

&lt;p&gt;t.Kind() == reflect.Float64  可以直接进行比较，结果为true 或者 false的布尔值&lt;/p&gt;

&lt;p&gt;t.String() 跟直接fmt.Println(t) 结果是一样的&lt;/p&gt;

&lt;p&gt;t.NumField() 返回字段的个数&lt;/p&gt;

&lt;p&gt;t.Field(i) 返回某一个字段的 StructField 结构&lt;/p&gt;

&lt;p&gt;fieldType := t.Field(i) ; fieldType.Name, fieldType.Tag 返回某一个字段的名字 和 tag信息&lt;/p&gt;

&lt;p&gt;fieldType := t.Field(i) ; fieldType.Tag.Get(“json”)  从tag中获取特定的tag信息&lt;/p&gt;

&lt;p&gt;t_ptr.NumMethod() 返回方法的数量 （此处要注意：结构体的方法使用指针定义的，所以用指针来获取）&lt;/p&gt;

&lt;p&gt;t_ptr.Method(i) 返回某一个方法的 reflect.Method , 是string类型&lt;/p&gt;

&lt;p&gt;method_name := t_ptr.Method(i) ; method_name.Name  返回某一个方法的名字&lt;/p&gt;

&lt;h3 id=&quot;获取结构体的成员的方法&quot;&gt;获取结构体的成员的方法&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Field(i int) StructField&lt;/td&gt;
      &lt;td&gt;根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生宕机&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NumField() int&lt;/td&gt;
      &lt;td&gt;返回结构体成员字段数量。当类型不是结构体或索引超界时发生宕机&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FieldByName(name string) (StructField, bool)&lt;/td&gt;
      &lt;td&gt;根据给定字符串返回字符串对应的结构体字段的信息。没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FieldByIndex(index []int) StructField&lt;/td&gt;
      &lt;td&gt;多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时 发生宕机&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FieldByNameFunc( match func(string) bool) (StructField,bool)&lt;/td&gt;
      &lt;td&gt;根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生宕机&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;获取结构体标签struct-tag的方法&quot;&gt;获取结构体标签（Struct Tag）的方法：&lt;/h3&gt;

&lt;p&gt;使用 StructField 中 Tag 的 Get() 方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typeOfCat := reflect.TypeOf(cat{})
if catType, ok := typeOfCat.FieldByName(&quot;Type&quot;); ok {
    fmt.Println(catType.Tag.Get(&quot;json&quot;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go语言通过反射获取-value-的相关方法&quot;&gt;Go语言通过反射获取 Value 的相关方法&lt;/h2&gt;

&lt;h3 id=&quot;基本的方法-1&quot;&gt;基本的方法：&lt;/h3&gt;

&lt;p&gt;v_ptr := reflect.ValueOf(&amp;amp;x) 返回一个Value 值类型&lt;/p&gt;

&lt;p&gt;v := v_ptr.Elem() 从指针获取值 , 返回一个reflect.Value对象&lt;/p&gt;

&lt;p&gt;v.Kind()  返回const定义的常量&lt;/p&gt;

&lt;p&gt;v.Type()  获取反射对象的 Type&lt;/p&gt;

&lt;p&gt;v.Kind() == reflect.Float64  可以直接进行比较，结果为true 或者 false的布尔值&lt;/p&gt;

&lt;p&gt;v.Field(i)  返回一个Value对象&lt;/p&gt;

&lt;p&gt;v.NumField() int	返回结构体成员字段数量&lt;/p&gt;

&lt;p&gt;v.NumMethod()  返回方法的数量&lt;/p&gt;

&lt;p&gt;v_ptr.Method(i)   返回一个reflect.Value对象&lt;/p&gt;

&lt;p&gt;me := v_ptr.Method(i) ; me.Type()  返回一个reflect.Type 类型 ，拥有上面介绍的type的所有方法&lt;/p&gt;

&lt;p&gt;me := v_ptr.Method(0); v_ptr.Method(0).Call()&lt;/p&gt;

&lt;h3 id=&quot;从反射值对象获取被包装的值&quot;&gt;从反射值对象获取被包装的值&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法名&lt;/th&gt;
      &lt;th&gt;说  明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Interface() interface {}&lt;/td&gt;
      &lt;td&gt;将值以 interface{} 类型返回，可以通过类型断言转换为指定类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Int() int64&lt;/td&gt;
      &lt;td&gt;将值以 int 类型返回，所有有符号整型均可以此方式返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Uint() uint64&lt;/td&gt;
      &lt;td&gt;将值以 uint 类型返回，所有无符号整型均可以此方式返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Float() float64&lt;/td&gt;
      &lt;td&gt;将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bool() bool&lt;/td&gt;
      &lt;td&gt;将值以 bool 类型返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bytes() []bytes&lt;/td&gt;
      &lt;td&gt;将值以字节数组 []bytes 类型返回&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;String() string&lt;/td&gt;
      &lt;td&gt;将值以字符串类型返回&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;反射访问结构体成员的值&quot;&gt;反射访问结构体成员的值&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方  法&lt;/th&gt;
      &lt;th&gt;备  注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Field(i int) Value&lt;/td&gt;
      &lt;td&gt;根据索引，返回索引对应的结构体成员字段的反射值对象。当值不是结构体或索引超界时发生宕机&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NumField() int&lt;/td&gt;
      &lt;td&gt;返回结构体成员字段数量。当值不是结构体或索引超界时发生宕机&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FieldByName(name string) Value&lt;/td&gt;
      &lt;td&gt;根据给定字符串返回字符串对应的结构体字段。没有找到时返回零值，当值不是结构体或索引超界时发生宕机&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FieldByIndex(index []int) Value&lt;/td&gt;
      &lt;td&gt;多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的值。 没有找到时返回零值，当值不是结构体或索引超界时发生宕机&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FieldByNameFunc(match func(string) bool) Value&lt;/td&gt;
      &lt;td&gt;根据匹配函数匹配需要的字段。找到时返回零值，当值不是结构体或索引超界时发生宕机&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;go语言通过反射修改变量的值&quot;&gt;GO语言通过反射修改变量的值&lt;/h2&gt;

&lt;p&gt;修改普通变量值得例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;reflect&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;声明整型变量&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;并赋初值&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1024&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;获取变量&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的反射值对象&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的地址&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;valueOfA&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reflect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ValueOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;取出&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;地址的元素&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的值&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;valueOfA&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valueOfA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;修改&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的值为&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;valueOfA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;打印&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的值&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valueOfA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;修改结构体值得例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;reflect&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;LegCount&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;获取&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;实例地址的反射值对象&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;valueOfDog&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reflect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ValueOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;取出&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;实例地址的元素&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;valueOfDog&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valueOfDog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;获取&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;legCount&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;字段的值&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vLegCount&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valueOfDog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FieldByName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;LegCount&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;尝试设置&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;legCount&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的值&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;这里会发生崩溃&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;vLegCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vLegCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go语言通过反射调用函数&quot;&gt;Go语言通过反射调用函数&lt;/h2&gt;

&lt;p&gt;如果反射值对象（reflect.Value）中值的类型为函数时，可以通过 reflect.Value 调用该函数。使用反射调用函数时，需要将参数使用反射值对象的切片 []reflect.Value 构造后传入 Call() 方法中，调用完成时，函数的返回值通过 []reflect.Value 返回。&lt;/p&gt;

&lt;p&gt;下面的代码声明一个加法函数，传入两个整型值，返回两个整型值的和。将函数保存到反射值对象（reflect.Value）中，然后将两个整型值构造为反射值对象的切片（[]reflect.Value），使用 Call() 方法进行调用。&lt;/p&gt;

&lt;p&gt;反射调用函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;reflect&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;普通函数&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;将函数包装为反射值对象&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;funcValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reflect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ValueOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;构造函数参数&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;传入两个整型值&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;paramList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reflect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reflect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ValueOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reflect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ValueOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;反射调用函数&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;retList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;funcValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;paramList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;获取第一个返回值&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;取整数值&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码说明如下：&lt;/p&gt;

&lt;p&gt;第 9～12 行，定义一个普通的加法函数。&lt;/p&gt;

&lt;p&gt;第 17 行，将 add 函数包装为反射值对象。&lt;/p&gt;

&lt;p&gt;第 20 行，将 10 和 20 两个整型值使用 reflect.ValueOf 包装为 reflect.Value，再将反射值对象的切片 []reflect.Value 作为函数的参数。&lt;/p&gt;

&lt;p&gt;第 23 行，使用 funcValue 函数值对象的 Call() 方法，传入参数列表 paramList 调用 add() 函数。&lt;/p&gt;

&lt;p&gt;第 26 行，调用成功后，通过 retList[0] 取返回值的第一个参数，使用 Int 取返回值的整数值。&lt;/p&gt;

&lt;p&gt;提示&lt;/p&gt;

&lt;p&gt;反射调用函数的过程需要构造大量的 reflect.Value 和中间变量，对函数参数值进行逐一检查，还需要将调用参数复制到调用函数的参数内存中。调用完毕后，还需要将返回值转换为 reflect.Value，用户还需要从中取出调用值。因此，反射调用函数的性能问题尤为突出，不建议大量使用反射函数调用。&lt;/p&gt;

&lt;h2 id=&quot;一个完整的例子&quot;&gt;一个完整的例子：&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Stu struct{


	Name string `json:&quot;stu_name&quot;`
	Age int
}

func (s *Stu) Printstu() {

	fmt.Println(&quot;xxxxx&quot;,s)
}


func (s *Stu) Printage(a int, b int ) int {

	fmt.Println(&quot;xxxxx &quot;,s)
	fmt.Println(&quot;result is &quot;, a+b)

	return a+b
}

func test_reflect(){




	var stu *Stu = &amp;amp;Stu{&quot;zhangsan&quot;,10,}
	stu.Printstu()

	t_ptr := reflect.TypeOf(stu)

	t:=t_ptr.Elem()

	fmt.Println(t)
	fmt.Printf(&quot;t Name() is %v&quot;,t.Name())
	fmt.Println()
	fmt.Printf(&quot;t Kind() is %v\n&quot;,t.Kind())

	fmt.Printf(&quot;t String() is %v&quot;,t.String())
	fmt.Println()
	fmt.Printf(&quot;t NumField() is %v&quot;,t.NumField())
	fmt.Println()
	fmt.Printf(&quot;t_ptr NumMethod() is %v \n&quot;,t_ptr.NumMethod())


	fmt.Printf(&quot;t_ptr Method(0) is %T %v \n &quot;,t_ptr.Method(0),t_ptr.Method(0))

	fmt.Printf(&quot;t_ptr Method(0).Name is %v \n &quot;,t_ptr.Method(0).Name)  //Printstu

	fmt.Println()
	fmt.Printf(&quot;t Field(1) is %T %v&quot;,t.Field(0),t.Field(0))
	fmt.Println()
	fmt.Printf(&quot;t Field(1).Name is %v&quot;,t.Field(0).Name)
	fmt.Println()
	fmt.Printf(&quot;t Field(1).Tag is %s&quot;,t.Field(0).Tag)
	fmt.Println()


	fmt.Printf(&quot;t Field(1).Tag.Get('json') is %s \n &quot;,t.Field(0).Tag.Get(&quot;json&quot;))

	s,ok:=t.FieldByName(&quot;Name&quot;)
	if ok {

		fmt.Println(s.Name )
		fmt.Println(s.Tag )
	}


	v_ptr := reflect.ValueOf(stu)

	v:=v_ptr.Elem()

	fmt.Println(v)

	fmt.Println()
	fmt.Printf(&quot;v Type() is %T %v \n&quot;,v.Type(),v.Type())

	fmt.Printf(&quot;v Type().Field(0) is %T %v %v\n&quot;,v.Type().Field(0),v.Type().Field(0),v.Type().Field(0).Name)

	fmt.Printf(&quot;v Kind() is %v&quot;,v.Kind())
	fmt.Println()
	fmt.Printf(&quot;v NumField() is %v&quot;,v.NumField())
	fmt.Println()
	fmt.Printf(&quot;v_ptr NumMethod() is %v \n &quot;,v_ptr.NumMethod())

	fmt.Printf(&quot;v_ptr Method(0) is %T %v \n&quot;,v_ptr.Method(0),v_ptr.Method(0))



	fmt.Printf(&quot;v_ptr Method(0).Type() is %T %v \n&quot;,v_ptr.Method(0).Type(),v_ptr.Method(0))

	fmt.Printf(&quot;v_ptr Method(0).Type().Name() String() is %v %v \n&quot;,v_ptr.Method(0).Type().Name(),v_ptr.Method(0).Type().String())



	var paramList0  []reflect.Value   // 没有值得情况

	retList0 :=v_ptr.Method(1).Call(paramList0)
	fmt.Println(retList0)

	paramList1 := []reflect.Value{reflect.ValueOf(10),reflect.ValueOf(20)}  // 传值的情况

	retList1  := v_ptr.Method(0).Call(paramList1)

	fmt.Println(retList1)

	fmt.Println(retList1[0].Int())  // 获取第一个返回值, 取整数值

	fmt.Println()
	fmt.Printf(&quot;v Field(1) is %T %v&quot;,v.Field(0),v.Field(0))
	fmt.Println()
	fmt.Printf(&quot;v Field(1).CanSet is %v&quot;,v.Field(0).CanSet())
	fmt.Println()
	fmt.Printf(&quot;v Field(1).Interface is %s&quot;,v.Field(0).Interface())
	fmt.Println()

	fmt.Printf(&quot;v FieldByName('Name').Interface is %T %s \n&quot;,v.FieldByName(&quot;Name&quot;),v.FieldByName(&quot;Name&quot;).Interface())





}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;main.Stu
t Name() is Stu
t Kind() is struct
t String() is main.Stu
t NumField() is 2
t_ptr NumMethod() is 2 
t_ptr Method(0) is reflect.Method {Printage  func(*main.Stu, int, int) int &amp;lt;func(*main.Stu, int, int) int Value&amp;gt; 0} 
 t_ptr Method(0).Name is Printage 
 
t Field(1) is reflect.StructField {Name  string json:&quot;stu_name&quot; 0 [0] false}
t Field(1).Name is Name
t Field(1).Tag is json:&quot;stu_name&quot;
t Field(1).Tag.Get('json') is stu_name 
 Name
json:&quot;stu_name&quot;
{zhangsan 10}

v Type() is *reflect.rtype main.Stu 
v Type().Field(0) is reflect.StructField {Name  string json:&quot;stu_name&quot; 0 [0] false} Name
v Kind() is struct
v NumField() is 2
v_ptr NumMethod() is 2 
 v_ptr Method(0) is reflect.Value 0x49d570 
v_ptr Method(0).Type() is *reflect.rtype 0x49d570 
v_ptr Method(0).Type().Name() String() is  func(int, int) int 
xxxxx &amp;amp;{zhangsan 10}
[]
xxxxx  &amp;amp;{zhangsan 10}
result is  30
[&amp;lt;int Value&amp;gt;]
30

v Field(1) is reflect.Value zhangsan
v Field(1).CanSet is true
v Field(1).Interface is zhangsan
v FieldByName('Name').Interface is reflect.Value zhangsan 	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 05 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:9000/2019/09/Go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84-reflection-%E7%AE%80%E8%BF%B0/</link>
        <guid isPermaLink="true">http://0.0.0.0:9000/2019/09/Go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84-reflection-%E7%AE%80%E8%BF%B0/</guid>
        
        <category>GO语言</category>
        
        
      </item>
    
      <item>
        <title>Go语言接口（interface）</title>
        <description>&lt;h2 id=&quot;go语言接口声明定义&quot;&gt;Go语言接口声明（定义）&lt;/h2&gt;

&lt;h2 id=&quot;接口被实现的条件&quot;&gt;接口被实现的条件&lt;/h2&gt;

&lt;h5 id=&quot;1-接口的方法与实现接口的类型方法格式一致&quot;&gt;&lt;strong&gt;1. 接口的方法与实现接口的类型方法格式一致&lt;/strong&gt;&lt;/h5&gt;

&lt;h5 id=&quot;2-接口中所有方法均被实现-实现了接口里面所有的方法才叫实现了接口只包含部分方法就没有实现这个接口&quot;&gt;&lt;strong&gt;2. 接口中所有方法均被实现： 实现了接口里面所有的方法才叫实现了接口。只包含部分方法就没有实现这个接口&lt;/strong&gt;&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 接口的声明

type Writer interface{

	writedata(v interface{})(n int ,err error)

}
type Reader interface{

	readdata(v interface{})

}

type File struct{}


func (f *File) writedata(v interface{})(n int ,err error){

	fmt.Println(&quot;writedata:&quot;, v)
	return

}

func (f *File) readdata(v interface{}){

	fmt.Println(&quot;readedata:&quot;, v)
	return             // 函数的裸返回，跟定义的返回值变量名一样，没定义就返回空 


	fmt.Println(&quot;end:&quot;)
}


func e1(){

	var write Writer = &amp;amp;File{}
	fmt.Println(write)

	n,err:=write.writedata(&quot;write a few data&quot;)

	fmt.Println(n,err)


	var read Reader = &amp;amp;File{}

	read.readdata(&quot;read a few data&quot;)

}

运行的结果：

&amp;amp;{}
writedata: write a few data
0 &amp;lt;nil&amp;gt;
readedata: read a few data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go语言类型与接口的关系&quot;&gt;Go语言类型与接口的关系&lt;/h2&gt;

&lt;h5 id=&quot;1-每一个struct-类型结构体可以实现多个接口&quot;&gt;&lt;strong&gt;1. 每一个struct 类型结构体可以实现多个接口&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。&lt;/p&gt;

&lt;h5 id=&quot;2-多个类型可以实现相同的接口&quot;&gt;&lt;strong&gt;2. 多个类型可以实现相同的接口&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。&lt;/p&gt;

&lt;h5 id=&quot;把-socket-能够写入数据和需要关闭的特性使用接口来描述请参考下面的代码&quot;&gt;把 Socket 能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码：&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type writer interface{

	writedata([]byte)(n int,err error) 
}


  


type closer interface{

	close()(err error) 
}

type socket struct{} 


func (s *socket) writedata(p []byte)(n int,err error) {

	fmt.Println(string(p)) 
	return 0 , nil 




}


func (s *socket) close() error{

	return nil 
}


func usingwriter(write writer){

	write.writedata([]byte(&quot;hello world&quot;))

}


func usingcloser(close  closer){

	close.close() 
}

func main(){

// 实例化socket 
var i *socket = &amp;amp;socket{}


// socket 类型实现了writer 和 closer 两个接口 
usingwriter(i) 
usingcloser(i) 


}


usingWriter() 和 usingCloser() 完全独立，互相不知道对方的存在，也不知道自己使用的接口是 Socket 实现的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Service 接口定义了两个方法：一个是开启服务的方法（Start()），一个是输出日志的方法（Log()）。使用 GameService 结构体来实现 Service，GameService 自己的结构只能实现 Start() 方法，而 Service 接口中的 Log() 方法已经被一个能输出日志的日志器（Logger）实现了，无须再进行 GameService 封装，或者重新实现一遍。所以，选择将 Logger 嵌入到 GameService 能最大程度地避免代码冗余&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Service interface{

	Start()
	Log() 

}

type Logger struct{

}

func (l *Logger) Log(){



}


type GameService struct{
	Logger 

}

func (g *GameService) Start(){


}


func main(){

var service  Service = &amp;amp;GameService{}
service.Start()
service.Log()

}


service 就可以使用 Start() 方法和 Log() 方法，其中，Start() 由 GameService 实现，Log() 方法由 Logger 实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go语言类型断言&quot;&gt;Go语言类型断言&lt;/h2&gt;

&lt;h5 id=&quot;go语言中有四种接口相关的类型转换情形&quot;&gt;&lt;strong&gt;Go语言中有四种接口相关的类型转换情形：&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&quot;-将一个非接口值转换为一个接口类型在这样的转换中此非接口值的类型必须实现了此接口类型&quot;&gt;● &lt;strong&gt;将一个非接口值转换为一个接口类型。在这样的转换中，此非接口值的类型必须实现了此接口类型。&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&quot;-将一个接口值转换为另一个接口类型前者接口值的类型实现了后者目标接口类型&quot;&gt;● &lt;strong&gt;将一个接口值转换为另一个接口类型（前者接口值的类型实现了后者目标接口类型）。&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&quot;-将一个接口值转换为一个非接口类型此非接口类型必须实现了此接口值的接口类型&quot;&gt;● &lt;strong&gt;将一个接口值转换为一个非接口类型（此非接口类型必须实现了此接口值的接口类型）。&lt;/strong&gt;&lt;/h5&gt;
&lt;h5 id=&quot;-将一个接口值转换为另一个接口类型前者接口值的类型可以实现了也可以未实现后者目标接口类型&quot;&gt;● &lt;strong&gt;将一个接口值转换为另一个接口类型（前者接口值的类型可以实现了也可以未实现后者目标接口类型）。&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;本节将介绍后面两种情形。这两种情形的合法性是在运行时刻通过类型断言来验证的。 事实上，类型断言同样也适用于上面列出的第二种情形。&lt;/p&gt;

&lt;h3 id=&quot;断言的语法&quot;&gt;断言的语法&lt;/h3&gt;

&lt;h5 id=&quot;1-断言被用做一个单值表达式-断言成功返回值断言失败会引起恐慌&quot;&gt;&lt;strong&gt;1. 断言被用做一个单值表达式 ，断言成功返回值。断言失败会引起恐慌&lt;/strong&gt;&lt;/h5&gt;

&lt;h5 id=&quot;2-断言返回两个结果的多值表达式断言成功返回值和一个true-的bool类型-断言失败返回零值-nil-接口值-和-flase&quot;&gt;&lt;strong&gt;2. 断言返回两个结果的多值表达式，断言成功返回值，和一个true 的bool类型， 断言失败返回零值 nil 接口值 ，和 flase&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;【示例 1】断言类型为非接口类型 : 将一个接口值转换为一个非接口类型&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {
	var x interface{} = &quot;123&quot;  //声明一个接口类型

	rel,ok := x.(int)          //断言类型为非接口类型 
	fmt.Println(rel,ok)        // 123, true 
	
	
	rel := x.(int)  
	fmt.Println(rel)  		   // 123 
	
	rel,ok := x.(float32)      //断言类型为非接口类型 
	fmt.Println(rel,ok)        // 0, false 
	
	
	rel:= x.(float32)          
	fmt.Println(rel)           //断言失败单值表达式 会产生恐慌 


}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;【示例 2】断言类型为接口类型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Write interface{

	write() 
}



type Summerywrite struct {

}

func ( s *Summerywrite) write(){} 




func main(){

	var a interface{}  = Summerywrite{}

	var a1 interface{}  = &amp;amp;Summerywrite{}


	var b interface{}  = &quot;hello&quot;  // b的动态类型为内置类型string


	var c Write = &amp;amp;Summerywrite{}


	rel1,ok1 := a.(Write)
	fmt.Println(rel1,ok1)              // &amp;lt;nil&amp;gt; false


	rel2,ok2 := a1.(Write)
	fmt.Println(rel2,ok2)              //  &amp;amp;{} true

	rel3,ok3 := b.(Write)
	fmt.Println(rel3,ok3)             // &amp;lt;nil&amp;gt; false


	var result interface{}              //先定义类型，在进行断言测试
	var is_boo bool
	result,is_boo = c.(interface{})     //c 实现了interface() 和 Write 两个接口

	fmt.Println(result,is_boo)           //  &amp;amp;{} true 

	rel:= b.(Write)                     // 断言失败出现恐慌
	fmt.Println(rel)                    // panic: interface conversion: string is not main.Write: missing method write




}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;断言类型实现接口转换&quot;&gt;断言类型实现接口转换&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var w io.Writer
w = os.Stdout
f := w.(*os.File) // 成功: f == os.Stdout
c := w.(*bytes.Buffer) // 死机：接口保存*os.file，而不是*bytes.buffer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;1-将接口转换为其他接口&quot;&gt;&lt;strong&gt;1. 将接口转换为其他接口&lt;/strong&gt;&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var obj interface = new(bird)
f, isFlyer := obj.(Flyer)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码中，new(bird) 产生 *bird 类型的 bird 实例，这个实例被保存在 interface{} 类型的 obj 变量中。使用 obj.(Flyer) 类型断言，将 obj 转换为 Flyer 接口。f 为转换成功时的 Flyer 接口类型，isFlyer 表示是否转换成功，类型就是 bool。&lt;/p&gt;

&lt;h5 id=&quot;2-将接口转换为其他类型&quot;&gt;&lt;strong&gt;2. 将接口转换为其他类型&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;可以实现将接口转换为普通的指针类型。例如将 Walker 接口转换为 *pig 类型，请参考下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;p1 := new(pig)
var a Walker = p1
p2 := a.(*pig)
fmt.Printf(&quot;p1=%p p2=%p&quot;, p1, p2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go语言接口的嵌套组合&quot;&gt;Go语言接口的嵌套组合&lt;/h2&gt;

&lt;h5 id=&quot;例一&quot;&gt;例一&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Reader interface{

	Read() 

}

type Writer interface{

	Writer() 
}


type ReadWriter interface{
	Reader 
	Writer 


}

type File struct{


}

func (f *File) Read(){}

func (f *File) Writer(){}

func test(rw ReadWriter){

	rw.Read() 
	rw.Writer()
}

test(&amp;amp;File{})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;例二&quot;&gt;例二&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;包&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Closer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WriteCloser&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Closer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;



&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;包&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;io&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;



&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;声明一个设备结构&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;实现&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;方法&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;实现&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Closer&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;方法&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;声明写入关闭器&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;并赋予&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的实例&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WriteCloser&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;写入数据&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;关闭设备&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;声明写入器&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;并赋予&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的新实例&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeOnly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;写入数据&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;writeOnly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go语言空接口类型interface&quot;&gt;Go语言空接口类型（interface{}）&lt;/h2&gt;

&lt;h5 id=&quot;1-将值保存到空接口&quot;&gt;1. 将值保存到空接口&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var any interface{}  

any = 1 
fmt.Println(any) 


any = true 
fmt.Println(any) 

any = false 
fmt.Println(any) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2-从空接口获取值&quot;&gt;2. 从空接口获取值&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var i interface{} = 1 

var b int 
b = i              // 触发宕机了，空接口不能直接转换为int

b = i.(int)       // 通过断言进行类型转换
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go语言类型分支switch判断空接口中变量的类型&quot;&gt;Go语言类型分支（switch判断空接口中变量的类型）&lt;/h2&gt;

&lt;p&gt;一个 type-switch 流程控制代码块的语法如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch t := areaIntf.(type) {
case *Square:
	fmt.Printf(&quot;Type Square %T with value %v\n&quot;, t, t)
case *Circle:
	fmt.Printf(&quot;Type Circle %T with value %v\n&quot;, t, t)
case nil:
	fmt.Printf(&quot;nil value: nothing to check?\n&quot;)
default:
	fmt.Printf(&quot;Unexpected type %T\n&quot;, t)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面的例子将一个 interface{} 类型的参数传给 printType() 函数，通过 switch 判断 v 的类型，然后打印对应类型的提示，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;is int&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;is string&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;is bool&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pig&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go语言排序借助sortinterface接口&quot;&gt;Go语言排序（借助sort.Interface接口）&lt;/h2&gt;

&lt;h5 id=&quot;原理-sortsortv-sortinterface-函数实现排序接受一个sortinterface-的参数&quot;&gt;&lt;strong&gt;原理： sort.Sort(v sort.Interface) 函数实现排序,接受一个sort.Interface 的参数&lt;/strong&gt;&lt;/h5&gt;

&lt;h5 id=&quot;一个内置的排序算法需要知道三个东西序列的长度表示两个元素比较的结果一种交换两个元素的方式这就是sortinterface-的三个方法&quot;&gt;&lt;strong&gt;一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是sort.Interface 的三个方法：&lt;/strong&gt;&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;获取元素数量&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Less&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;是序列元素的指数。&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;交换元素&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自定义切片-string-的排序方法&quot;&gt;自定义切片 []string 的排序方法&lt;/h3&gt;

&lt;h3 id=&quot;内置的切片排序方法&quot;&gt;内置的切片排序方法&lt;/h3&gt;

&lt;p&gt;使用 sort 包的 StringSlice 类型就可以更简单快速地进行字符串切片排序 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main(){
	var str sort.StringSlice

	str = sort.StringSlice{
		&quot;apple&quot;,&quot;banana&quot;,&quot;taozi&quot;,&quot;xigua&quot;,&quot;why&quot;,&quot;cm&quot;,
	}


	sort.Sort(str)

	fmt.Println(str)  // [apple banana cm taozi why xigua]

}	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 sort 包的sort.IntSlice 类型进行整型切片的排序&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func sort_int(){

	var i sort.IntSlice  = sort.IntSlice{6,8,9,3,2,7}

	sort.Sort(i)

	fmt.Println(i) // [2 3 6 7 8 9]


}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 sort.Strings 函数直接对字符串切片进行排序&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func sort_str1(){

	var str []string = []string{&quot;apple&quot;,&quot;banana&quot;,&quot;taozi&quot;,&quot;xigua&quot;,&quot;why&quot;,&quot;cm&quot;,}

	sort.Strings(str)

	fmt.Println(str)  // [apple banana cm taozi why xigua]


}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 sort.Ints 函数直接对字符串切片进行排序&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func sort_int1(){


	var i []int = []int{6,8,9,3,2,7}

	sort.Ints(i)

	fmt.Println(i)

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Go语言中的 sort 包中定义了一些常见类型的排序方法，如下表所示。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;sort 包中内建的类型排序接口：&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;字符串（String）：&lt;/td&gt;
      &lt;td&gt;StringSlice&lt;/td&gt;
      &lt;td&gt;sort.Strings(a [] string)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;整型（int）：&lt;/td&gt;
      &lt;td&gt;IntSlice&lt;/td&gt;
      &lt;td&gt;sort.Ints(a []int)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;双精度浮点（float64）：&lt;/td&gt;
      &lt;td&gt;Float64Slice&lt;/td&gt;
      &lt;td&gt;sort.Float64s(a []float64)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;编程中经常用到的 int32、int64、float32、bool 类型并没有由 sort 包实现，使用时依然需要开发者自己编写。&lt;/p&gt;

&lt;h3 id=&quot;自定义结构体的排序方法&quot;&gt;自定义结构体的排序方法&lt;/h3&gt;

&lt;h3 id=&quot;内置的sortslice-进行结构体排-使用sortslice进行切片元素排序&quot;&gt;内置的sort.Slice 进行结构体排， 使用sort.Slice进行切片元素排序&lt;/h3&gt;

&lt;p&gt;sort.Slice() 函数的定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func Slice(slice interface{}, less func(i, j int) bool)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;将一批英雄名单使用结构体定义，英雄名单的结构体中定义了英雄的名字和分类。排序时要求按照英雄的分类进行排序，相同分类的情况下按名字进行排序，详细代码实现过程如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func sort_hero(){

	type HeroKind int
	const (
		None = iota
		Tank
		Assassin
		Mage
	)


	type Hero struct{
		name string
		kind HeroKind


	}

	var hero_se []*Hero = []*Hero{

		&amp;amp;Hero{&quot;张飞&quot;,Mage},
		&amp;amp;Hero{&quot;吕布&quot;,Assassin},
		&amp;amp;Hero{&quot;关于&quot;,Tank},
		&amp;amp;Hero{&quot;曹操&quot;,Assassin},
		&amp;amp;Hero{&quot;张辽&quot;,Mage},
		&amp;amp;Hero{&quot;孙权&quot;,Assassin},
		&amp;amp;Hero{&quot;周瑜&quot;,Tank},




	}

	sort.Slice(hero_se,func(i, j int)bool{

		return  hero_se[i].kind &amp;gt;  hero_se[j].kind


	})

	for index,v := range hero_se{

		fmt.Println(index, *v )

	}





}

	
运行的结果：
0 {张飞 3}
1 {张辽 3}
2 {吕布 2}
3 {曹操 2}
4 {孙权 2}
5 {关于 1}
6 {周瑜 1}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go语言error接口&quot;&gt;Go语言error接口：&lt;/h2&gt;

&lt;p&gt;error 类型，而且没有解释它究竟是什么。实际上它就是 interface 类型，这个类型有一个返回错误信息的单一方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type error interface {
	Error() string
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建一个 error 的方法&lt;/p&gt;

&lt;h5 id=&quot;1-调用-errorsnew-函数&quot;&gt;&lt;strong&gt;1. 调用 errors.New 函数&lt;/strong&gt;&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;errors.New(&quot;this is a error&quot;) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2-调用-fmterrorf它还会处理字符串格式化&quot;&gt;&lt;strong&gt;2. 调用 fmt.Errorf，它还会处理字符串格式化。&lt;/strong&gt;&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fmt.Errorf(&quot;this is a error %d %s&quot; , a, err) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go语言writer和reader接口简述&quot;&gt;Go语言Writer和Reader接口简述&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Writer interface {
	Write(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述代码中展示了 io.Writer 接口的声明。这个接口声明了唯一一个方法 Write，这个方法接受一个 byte 切片，并返回两个值。第一个值是写入的字节数，第二个值是 error 错误值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Reader interface {
	Read(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述代码中的 io.Reader 接口声明了一个方法 Read，这个方法接受一个 byte 切片，并返回两个值。第一个值是读入的字节数，第二个值是 error 错误值。&lt;/p&gt;

</description>
        <pubDate>Tue, 03 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:9000/2019/09/Go%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3-interface/</link>
        <guid isPermaLink="true">http://0.0.0.0:9000/2019/09/Go%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3-interface/</guid>
        
        <category>GO语言</category>
        
        
      </item>
    
      <item>
        <title>包概念与工厂模式</title>
        <description>&lt;h3 id=&quot;工厂模式自动注册管理多个包的结构体&quot;&gt;工厂模式自动注册——管理多个包的结构体&lt;/h3&gt;

&lt;p&gt;本例利用包的 init 特性，将 cls1 和 cls2 两个包注册到工厂，使用字符串创建这两个注册好的结构实例。&lt;/p&gt;

&lt;p&gt;完整代码的结构如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; .
&amp;gt; └── src
&amp;gt;     └── chapter08
&amp;gt;         └── clsfactory
&amp;gt;             ├── main.go
&amp;gt;             └── base
&amp;gt;                 └── factory.go
&amp;gt;             └── cls1
&amp;gt;                 └── reg.go
&amp;gt;             └── cls2
&amp;gt;                 └── reg.go
				
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;clsfactorybasefactorygo&quot;&gt;clsfactory/base/factory.go&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;定义一个借口&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;将结构体返回给接口即可&lt;/span&gt; 

&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;Know&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsmap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Registermap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;clsmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; 

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Callmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;f_func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
	
	&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Know&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
	
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;clsfactorycls1reggo&quot;&gt;clsfactory/cls1/reg.go&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls1&lt;/span&gt; 

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;clsfactory/base&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt; 

&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cls1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cls1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Know&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cls1 is knowing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Newcls1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cls1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cls1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Newcls1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	
	&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Registermap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cls1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;clsfactorycls2reggo&quot;&gt;clsfactory/cls2/reg.go&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cls2&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;clsfactory/base&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt; 

&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cls2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cls2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Know&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cls2 is knowing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Newcls2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cls2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cls2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Newcls2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	
	&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Registermap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cls2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;clsfactorymaingo&quot;&gt;clsfactory/main.go&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import &quot;clsfactory/base&quot;
import _ &quot;clsfactory/cls1&quot;
import _ &quot;clsfactory/cls2&quot;


func main(){


	base.Callmap(&quot;cls1&quot;)

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 02 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:9000/2019/09/%E5%8C%85%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">http://0.0.0.0:9000/2019/09/%E5%8C%85%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
        
        <category>GO语言</category>
        
        
      </item>
    
      <item>
        <title>Go语言结构体（struct）</title>
        <description>&lt;p&gt;本篇文章介绍Go语言结构体（struct）&lt;/p&gt;

&lt;h3 id=&quot;结构体定义&quot;&gt;结构体定义&lt;/h3&gt;

&lt;h5 id=&quot;1-结构体的定义格式&quot;&gt;1. 结构体的定义格式&lt;/h5&gt;

&lt;p&gt;使用结构体可以表示一个包含 X 和 Y 整型分量的点结构，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Point struct {
	X int
	Y int
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2-同类型的变量在一行的定义格式&quot;&gt;2. 同类型的变量在一行的定义格式&lt;/h5&gt;

&lt;p&gt;颜色的红、绿、蓝 3 个分量可以使用 byte 类型表示，定义的颜色结构体如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Color struct {
	R, G, B byte
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存。&lt;/p&gt;

&lt;h5 id=&quot;3-不可导出的变量不能被其他包所引用&quot;&gt;3. 不可导出的变量不能被其他包所引用&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;和&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;都是不可导出的，私有的变量&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;p&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;         &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;编译错误，无法引用&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;、&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;               &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;编译错误，无法引用&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;、&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然上面的最后一行代码没有显式地提到不可导出变量，但是它们被隐式地引用了，所以这也是不允许的。&lt;/p&gt;

&lt;h3 id=&quot;结构体初始化&quot;&gt;结构体初始化&lt;/h3&gt;

&lt;h5 id=&quot;1-使用键值对填充结构体的例子&quot;&gt;1. 使用键值对填充结构体的例子&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type People struct {
	name  string
	child *People
}

relation := &amp;amp;People{
	name: &quot;爷爷&quot;,
	child: &amp;amp;People{
		name: &quot;爸爸&quot;,
		child: &amp;amp;People{
				name: &quot;我&quot;,
		},
	},
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2-匿名结构体的初始化&quot;&gt;2. 匿名结构体的初始化&lt;/h5&gt;

&lt;p&gt;在本例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data）。打印消息内容的 printMsg() 函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;打印消息类型&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;传入匿名结构体&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printMsgType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;使用动词&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;打印&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;的类型&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%T&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;实例化一个匿名结构体&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;定义部分&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}{&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;值初始化部分&lt;/span&gt;
		&lt;span class=&quot;m&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;printMsgType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;结构体构造函数&quot;&gt;结构体构造函数&lt;/h3&gt;

&lt;h5 id=&quot;1-模拟结构体构造函数重载&quot;&gt;1. 模拟结构体构造函数重载&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Cat struct{

	name string 
	color string 

}


func NewCat(name string) *Cat{

	return &amp;amp;Cat{name:name,}

}


func NewBlankCat(color string) *Cat{

	return &amp;amp;Cat{color:color,} 

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2-父子结构体的构造和初始化&quot;&gt;2. 父子结构体的构造和初始化&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Car struct{

	name string 
	color string 

}

type BlankCar struct{
	Car 
	price float32


}



func NewCar(name,color string) *Car{

	return &amp;amp;Car{
		name:name,
		color:color,
	
	}

}


func NewBlankCar(name string,color string,price float32) *BlankCar{

	return &amp;amp;NewBlankCar{
		Car:Car{
			name:name,
			color:color,
		
		},
		price:price,
	
	}


}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;内嵌结构体&quot;&gt;内嵌结构体&lt;/h3&gt;

&lt;h5 id=&quot;1-内嵌结构体的初始化&quot;&gt;1. 内嵌结构体的初始化&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Wheel struct{

	Size int 
}

type Engine struct{

	Power int 
	Type string 
}


type Car struct{
	Wheel
	Engine 
}


func NewCar(Size int,Power int,Type string) *Car{


	return &amp;amp;Car{
		Wheel:Wheel{
			Size:Size,
		
		},
		
		Engine:Engine{
			Power:Power,
			Type:Type,
		},
	
	
	}


}

func main(){


var car *Car = NewCar(10,80,&quot;1.4T&quot;)
fmt.Println(car) 

} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;2-内嵌结构体的继承&quot;&gt;2. 内嵌结构体的继承&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Flying struct{

}

func (f *Flying) Fly(){

	fmt.Println(*f,&quot;is flying&quot;) 
}


type Walking struct{}


func (w *Walking) Walk(){

	fmt.Println(*w,&quot;is walking&quot;) 

}

type Bird struct{
	Flying
	Walking 

}


func NewBird() *Bird{

	return &amp;amp;Bird{}
}


func t_main(){

	var bird *Bird = NewBird()
	bird.Fly()
	bird.Walk() 

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;结构体的json序列化和反序列化&quot;&gt;结构体的json序列化和反序列化&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func j_main(){

var car *Car = NewCar(10,80,&quot;1.4T&quot;) 

data,_ := json.Marshal(car)
fmt.Println(string(data))


var car1 *Car = new(Car) 

json.Unmarshal(data,car1) 
fmt.Println(car1) 

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Fri, 30 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:9000/2019/08/%E7%BB%93%E6%9E%84%E4%BD%93/</link>
        <guid isPermaLink="true">http://0.0.0.0:9000/2019/08/%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
        
        <category>GO语言</category>
        
        
      </item>
    
      <item>
        <title>TIDB的安装</title>
        <description>&lt;p&gt;本篇文章介绍TIDB的安装&lt;/p&gt;

&lt;h3 id=&quot;中控机建用户&quot;&gt;中控机建用户&lt;/h3&gt;

&lt;p&gt;创建 tidb 用户&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;useradd -m -d /home/tidb tidb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;设置 tidb 用户密码
	passwd tidb&lt;/p&gt;

&lt;p&gt;配置 tidb 用户 sudo 免密码，将 tidb ALL=(ALL) NOPASSWD: ALL 添加到文件末尾即可。
	tidb ALL=(ALL) NOPASSWD: ALL&lt;/p&gt;

&lt;p&gt;生成 ssh key: 执行 su 命令从 root 用户切换到 tidb 用户下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# su - tidb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建 tidb 用户 ssh key， 提示 Enter passphrase 时直接回车即可。执行成功后，ssh 私钥文件为 /home/tidb/.ssh/id_rsa， ssh 公钥文件为 /home/tidb/.ssh/id_rsa.pub。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/tidb/.ssh/id_rsa):
Created directory '/home/tidb/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/tidb/.ssh/id_rsa.
Your public key has been saved in /home/tidb/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:eIBykszR1KyECA/h0d7PRKz4fhAeli7IrVphhte7/So tidb@172.16.10.49
The key's randomart image is:
+---[RSA 2048]----+
|=+o+.o.          |
|o=o+o.oo         |
| .O.=.=          |
| . B.B +         |
|o B * B S        |
| * + * +         |
|  o + .          |
| o  E+ .         |
|o   ..+o.        |
+----[SHA256]-----+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;中控机安装ansible-下载包拷贝到hometidb-下&quot;&gt;中控机安装ansible ，下载包。拷贝到/home/tidb 下&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd tidb-ansible
ansible-playbook local_prepare.yml

cp -r tidb-ansible  /home/tidb 
 
chown tidb.tidb -R /home/tidb/tidb-ansible/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;检查部署目标机ntp&quot;&gt;检查部署目标机ntp&lt;/h3&gt;

&lt;p&gt;执行 ntpstat 命令，输出 synchronised to NTP server(正在与 NTP server 同步)表示在正常同步：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ntpstat
synchronised to NTP server (85.199.214.101) at stratum 2
	time correct to within 91 ms
	polling server every 1024 s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用以下命令可使 NTP 服务尽快开始同步，pool.ntp.org 可替换为你的 NTP server：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo systemctl stop ntpd.service
$ sudo ntpdate ntpserver.yyinter.cn
$ sudo systemctl start ntpd.service

ntpstat
systemctl status ntpd.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 CentOS 7 系统上执行以下命令，可手工安装 NTP 服务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo yum install ntp ntpdate
$ sudo systemctl start ntpd.service
$ sudo systemctl enable ntpd.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;配置ssh-互信-ntp同步-cpu模式ext4-挂载参数等&quot;&gt;配置ssh 互信， ntp同步， cpu模式，ext4 挂载参数等&lt;/h3&gt;

&lt;p&gt;在中控机上配置部署机器 ssh 互信及 sudo 规则
参考在中控机上配置部署机器 ssh 互信及 sudo 规则即可。&lt;/p&gt;

&lt;p&gt;目标机关闭防火墙：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl stop  iptables.service  
systemctl status iptables.service  
systemctl status firewalld.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;hosts.ini修改为要部署的机器的ip：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;su - tidb 
cd /home/tidb/tidb-ansible
ansible-playbook -i hosts.ini create_users.yml -u root -k
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在部署目标机器上安装 NTP 服务
如果你的部署目标机器时间、时区设置一致，已开启 NTP 服务且在正常同步时间，此步骤可忽略，可参考如何检测 NTP 服务是否正常。&lt;/p&gt;

&lt;p&gt;修改hosts.ini中的配置为局域网ntpserver ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ntp_server = ntpserver.yyinter.cn
 
$ cd /home/tidb/tidb-ansible
$ ansible-playbook -i hosts.ini deploy_ntp.yml -u tidb -b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考在部署目标机器上安装 NTP 服务即可。&lt;/p&gt;

&lt;p&gt;在部署目标机器上配置 CPUfreq 调节器模式
本例中系统支持设置 performance 和 powersave 模式。如果返回 “Not Available”，表示当前系统不支持配置 CPUfreq，跳过该步骤即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cpupower frequency-info --governors
analyzing CPU 0:
	available cpufreq governors: Not Available
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你可以通过 cpupower 命令查看系统当前的 CPUfreq 调节器模式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cpupower frequency-info --policy
analyzing CPU 0:
	current policy: frequency should be within 1.20 GHz and 3.20 GHz.
              The governor &quot;powersave&quot; may decide which speed to use
              within this range.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考在部署目标机器上配置 CPUfreq 调节器模式即可。（虚拟机不可以改）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ansible -i hosts.ini all -m shell -a &quot;cpupower frequency-set --governor performance&quot; -u tidb -b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在部署目标机器上添加数据盘 ext4 文件系统挂载参数
参考在部署目标机器上添加数据盘 ext4 文件系统挂载参数即可。&lt;/p&gt;

&lt;h3 id=&quot;验证以及部署&quot;&gt;验证以及部署&lt;/h3&gt;

&lt;p&gt;分配机器资源，编辑 inventory.ini 文件&lt;/p&gt;

&lt;p&gt;安装的目录 deplay_dir 修改为 /data ,我的环境的安装目录，默认是/home/tidb/deplay&lt;/p&gt;

&lt;p&gt;执行以下命令如果所有 server 返回 tidb 表示 ssh 互信配置成功。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ansible -i inventory.ini all -m shell -a 'whoami'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行以下命令如果所有 server 返回 root 表示 tidb 用户 sudo 免密码配置成功。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ansible -i inventory.ini all -m shell -a 'whoami' -b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行 local_prepare.yml playbook，联网下载 TiDB binary 到中控机：（之前已执行）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ansible-playbook local_prepare.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;初始化系统环境，修改内核参数（此步骤验证机器的配置，不通过修改配置文件）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ansible-playbook bootstrap.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;部署 TiDB 集群软件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ansible-playbook deploy.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;初始化环境，检查相关的参数，部署通不过修改对应的值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim roles/check_system_optional/defaults/main.yml  

vim  /home/tidb/tidb-ansible/roles/machine_benchmark/defaults/main.yml 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考文档：&lt;a href=&quot;https://pingcap.com/docs-cn/v3.0/how-to/deploy/orchestrated/offline-ansible/&quot;&gt;部署tidb&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 30 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:9000/2019/08/TIDB%E7%9A%84%E5%AE%89%E8%A3%85/</link>
        <guid isPermaLink="true">http://0.0.0.0:9000/2019/08/TIDB%E7%9A%84%E5%AE%89%E8%A3%85/</guid>
        
        <category>TIDB学习</category>
        
        
      </item>
    
      <item>
        <title>我的测试博客</title>
        <description>&lt;p&gt;　　经过各种找资料，踩过各种坑，终于使用 hexo 搭建个人博客初步完成了，域名目前用得时 github 的，我的 hexo 是 3.1.1 版本，hexo 不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。&lt;/p&gt;

&lt;p&gt;　　本篇文章累计了大量评论，和我的一些解答，读者有什么问题可以先看看评论，或者搜下关键字，如果还是有问题可以给我在评论里给我留言，问题很着急的可以加我 ＱＱ：1499065178　，或者给我发邮件：&lt;a href=&quot;mailto:leopardpan@icloud.com&quot;&gt;leopardpan@icloud.com&lt;/a&gt;  ，都可以，如果你已经搭建完成了，可以看看我的另一篇博客&lt;a href=&quot;http://baixin.io/2016/06/HEXO_Advanced/&quot;&gt;HEXO进阶&lt;/a&gt;，有讲如何能百度搜索你的博客、多台电脑使用HEXO发布博客等。我现在的博客是使用 Jekyll 搭建的，如果你想使用我现在的模板请看&lt;a href=&quot;http://baixin.io/2016/10/jekyll_tutorials1/&quot;&gt;Jekyll搭建个人博客&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;
&lt;p&gt;　这边教程是针对与Mac的，&lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool&quot;&gt;参考链接&lt;/a&gt;，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。&lt;/p&gt;

&lt;p&gt;　之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我，不是太喜欢，简书还算好点得。最近看到一些大神们的博客（在我的友情链接里有），貌似都是用hexo写得，我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。&lt;/p&gt;

&lt;h2 id=&quot;配置环境&quot;&gt;配置环境&lt;/h2&gt;

&lt;h3 id=&quot;安装node必须&quot;&gt;安装Node（必须）&lt;/h3&gt;

&lt;p&gt;作用：用来生成静态页面的
到Node.js&lt;a href=&quot;https://nodejs.org/&quot;&gt;官网&lt;/a&gt;下载相应平台的最新版本，一路安装即可。&lt;/p&gt;

&lt;h3 id=&quot;安装git必须&quot;&gt;安装Git（必须）&lt;/h3&gt;
&lt;p&gt;作用：把本地的hexo内容提交到github上去.
安装Xcode就自带有Git，我就不多说了。&lt;/p&gt;

&lt;h3 id=&quot;申请github必须&quot;&gt;申请GitHub（必须）&lt;/h3&gt;
&lt;p&gt;作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。
&lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt;账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。&lt;/p&gt;

&lt;h3 id=&quot;正式安装hexo&quot;&gt;正式安装HEXO　&lt;/h3&gt;
&lt;p&gt;Node和Git都安装好后，可执行如下命令安装hexo：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo npm install -g hexo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;p&gt;创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;好啦，至此，全部安装工作已经完成！&lt;/p&gt;

&lt;h3 id=&quot;生成静态页面&quot;&gt;生成静态页面&lt;/h3&gt;
&lt;p&gt;继续再Blog目录下执行如下命令，生成静态页面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo generate （hexo g  也可以）   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;本地启动&quot;&gt;本地启动&lt;/h3&gt;
&lt;p&gt;启动本地服务，进行文章预览调试，命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo server   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;浏览器输入&lt;a href=&quot;就可以看到最原始的效果了&quot;&gt;http://localhost:4000&lt;/a&gt;
我不知道你们能不能，反正我不能，因为我还有环境没配置好&lt;/p&gt;

&lt;h3 id=&quot;常见的hexo配置错误&quot;&gt;常见的HEXO配置错误：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ERROR Plugin load failed: hexo-server

原因： Besides, utilities are separated into a standalone module. hexo.util is not reachable anymore.

解决方法，执行命令：$ sudo npm install hexo-server

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;执行命令hexo server，提示：Usage: hexo&amp;lt;Command&amp;gt; ....

原因：我认为是没有生成本地服务

解决方法，执行命令：$ npm install hexo-server --save

提示：hexo-server@0.1.2 node_modules/hexo-server
.... 

表示成功了[参考](https://hexo.io/zh-cn/docs/server.html)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个时候再执行：$ hexo-server&lt;/p&gt;

&lt;p&gt;得到: INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.&lt;/p&gt;

&lt;p&gt;这个时候再点击&lt;a href=&quot;http://0.0.0.0:4000&quot;&gt;http://0.0.0.0:4000&lt;/a&gt;，正常情况下应该是最原始的画面，但是我看到的是：
白板和Cannot GET /   几个字
原因： 由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install hexo-renderer-ejs --save
npm install hexo-renderer-stylus --save
npm install hexo-renderer-marked --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个时候再重新生成静态文件，命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo generate （或hexo g）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;启动本地服务器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo server （或hexo s）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再点击网址&lt;a href=&quot;http://0.0.0.0:4000&quot;&gt;http://0.0.0.0:4000&lt;/a&gt; OK终于可以看到属于你自己的blog啦，?，虽然很简陋，但好歹有了一个属于自己的小窝了。&lt;a href=&quot;https://disqus.com/home/discussion/bsspirit/hexogithubweb/&quot;&gt;参考链接&lt;/a&gt;，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。&lt;/p&gt;

&lt;h2 id=&quot;配置github&quot;&gt;配置Github&lt;/h2&gt;

&lt;h3 id=&quot;建立repository&quot;&gt;建立Repository&lt;/h3&gt;

&lt;p&gt;建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法
然后建立关联，我的Blog在本地/Users/leopard/Blog，Blog是我之前建的东西也全在这里面，有：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Blog      &lt;br /&gt;
　｜      &lt;br /&gt;
　｜－－ _config.yml     &lt;br /&gt;
　｜－－ node_modules    &lt;br /&gt;
　｜－－ public              &lt;br /&gt;
　｜－－ source                                                &lt;br /&gt;
　｜－－ db.json	        &lt;br /&gt;
　｜－－ package.json        &lt;br /&gt;
　｜－－ scaffolds        &lt;br /&gt;
　｜－－ themes          　　　　　
　　　&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在我们需要_config.yml文件，来建立关联，命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim _config.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;翻到最下面，改成我这样子的，注意： &lt;code class=&quot;highlighter-rouge&quot;&gt;: 后面要有空格&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deploy:
  type: git
  repository: https://github.com/leopardpan/leopardpan.github.io.git
  branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行如下命令才能使用git部署&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install hexo-deployer-git --save
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;网上会有很多说法，有的type是github, 还有repository 最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。
忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。
然后，执行配置命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;　然后再浏览器中输入&lt;a href=&quot;http://leopardpan.github.io/&quot;&gt;http://leopardpan.github.io/&lt;/a&gt;就行了，我的 github 的账户叫 leopardpan ,把这个改成你 github 的账户名就行了&lt;/p&gt;

&lt;h3 id=&quot;部署步骤&quot;&gt;部署步骤&lt;/h3&gt;

&lt;p&gt;每次部署的步骤，可按以下三步来进行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo clean
hexo generate
hexo deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一些常用命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）
hexo deploy #将.deploy目录部署到GitHub
hexo help  #查看帮助
hexo version  #查看Hexo的版本
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里有大量的&lt;a href=&quot;https://github.com/hexojs/hexo/wiki/Themes&quot;&gt;主题列表&lt;/a&gt;使用方法里面
都有详细的介绍，我就不多说了。    &lt;br /&gt;
我这里有几款个人认为不错的主题，免去你们，一个一个的选了，欢迎吐槽我的审美，?       &lt;br /&gt;
　&lt;a href=&quot;https://github.com/daisygao/hexo-themes-cover&quot;&gt;Cover&lt;/a&gt; - A chic theme with facebook-like cover photo    &lt;br /&gt;
　&lt;a href=&quot;https://github.com/henryhuang/oishi&quot;&gt;Oishi&lt;/a&gt; - A white theme based on Landscape plus and Writing.    &lt;br /&gt;
　&lt;a href=&quot;https://github.com/hardywu/hexo-theme-sidebar&quot;&gt;Sidebar&lt;/a&gt; - Another theme based on Light with a simple sidebar  &lt;br /&gt;
　&lt;a href=&quot;https://github.com/SuperKieran/TKL&quot;&gt;TKL&lt;/a&gt; - A responsive design theme for Hexo. 一个设计优雅的响应式主题  &lt;br /&gt;
　&lt;a href=&quot;https://github.com/levonlin/Tinnypp&quot;&gt;Tinnypp&lt;/a&gt; - A clean, simple theme based on Tinny   &lt;br /&gt;
　&lt;a href=&quot;https://github.com/yunlzheng/hexo-themes-writing&quot;&gt;Writing&lt;/a&gt; - A small and simple hexo theme based on Light   &lt;br /&gt;
　&lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot;&gt;Yilia&lt;/a&gt; - Responsive and simple style 优雅简洁响应式主题，我用得就是这个。  &lt;br /&gt;
　&lt;a href=&quot;https://github.com/Voidly/pacman&quot;&gt;Pacman voidy&lt;/a&gt; - A theme with dynamic tagcloud and dynamic snow&lt;/p&gt;

&lt;h3 id=&quot;一些基本路径&quot;&gt;一些基本路径&lt;/h3&gt;
&lt;p&gt;　文章在 source/_posts，编辑器可以用 Sublime，支持 markdown 语法。如果想修改头像可以直接在主题的 _config.yml 文件里面修改，友情链接，之类的都在这里，修改名字在 public/index.html 里修改，开始打理你的博客吧，有什么问题或者建议，都可以提出来，我会继续完善的。&lt;/p&gt;

&lt;p&gt;Markdown语法参考链接: &lt;a href=&quot;https://www.zybuluo.com/mdeditor&quot;&gt;作业部落&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;qa&quot;&gt;Q&amp;amp;A&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;问：如何让文章想只显示一部分和一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;阅读全文&lt;/code&gt; 的按钮？     &lt;br /&gt;
答：在文章中加一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; ， &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; 后面的内容就不会显示出来了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，&lt;code class=&quot;highlighter-rouge&quot;&gt;出现 404 &lt;/code&gt; .    &lt;br /&gt;
答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt;转载请注明原地址，潘柏信的博客：&lt;a href=&quot;http://leopardpan.github.io&quot;&gt;http://leopardpan.github.io&lt;/a&gt; 谢谢！&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:9000/2019/08/%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</link>
        <guid isPermaLink="true">http://0.0.0.0:9000/2019/08/%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</guid>
        
        <category>工具</category>
        
        
      </item>
    
      <item>
        <title>jekyll博客的部署</title>
        <description>&lt;p&gt;本篇文章介绍jekyll博客的部署&lt;/p&gt;

&lt;h2 id=&quot;使用-rvm-安装-ruby&quot;&gt;使用 RVM 安装 Ruby&lt;/h2&gt;

&lt;p&gt;RVM 能在系统中安装和管理多个 Ruby 版本。同时还能管理不同的 gem 集。支持 OS X、Linux 和其它类 UNIX 操作系统。&lt;/p&gt;

&lt;h3 id=&quot;安装-rvm&quot;&gt;安装 RVM&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB
$ curl -sSL https://get.rvm.io | bash -s stable 安装完成后，会列出一些安装信息，其中有一行要注意：
...
To start using RVM you need to run `source /etc/profile.d/rvm.sh`
....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;意思是如果要开始使用需要执行一个 source 命令来重新执行刚修改的初始化文件，根据安装提示，执行以下命令载入 RVM 环境（新开 Termal 就不用这么做了，会自动重新载入的）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source /etc/profile.d/rvm.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;检查一下是否安装正确&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm -v
rvm 1.22.17 (stable) by Wayne E. Seguin &amp;lt;wayneeseguin@gmail.com&amp;gt;, Michal Papis &amp;lt;mpapis@gmail.com&amp;gt; [https://rvm.io/] ### 用 RVM 安装 Ruby 环境   列出已知的 ruby 版本:

$ rvm list known
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以选择现有的 rvm 版本来进行安装（下面以 rvm 2.6.3 版本的安装为例）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm install 2.6.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样继续等待漫长的下载，编译过程，完成以后，Ruby, Ruby Gems 就安装好了。&lt;/p&gt;

&lt;h3 id=&quot;设置-ruby-版本&quot;&gt;设置 Ruby 版本&lt;/h3&gt;

&lt;p&gt;RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm 2.6.3 --default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样，也可以用其他版本号，前提是你有用 rvm install 安装过那个版本&lt;/p&gt;

&lt;p&gt;这个时候你可以测试是否正确&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ruby -v
ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-darwin13.0.0]

$ gem -v
2.1.6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;替换-ruby-的默认源替换方式如下&quot;&gt;替换 Ruby 的默认源替换方式如下：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem source -r https://rubygems.org/
$ gem source -a https://gems.ruby-china.com/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要想验证是否替换成功了，可以执行：&lt;/p&gt;

&lt;p&gt;$ gem sources -l&lt;/p&gt;

&lt;p&gt;正常的输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*** CURRENT SOURCES ***

https://gems.ruby-china.com/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请确保只有 gems.ruby-china.com&lt;/p&gt;

&lt;h3 id=&quot;安装jekyll&quot;&gt;安装Jekyll&lt;/h3&gt;

&lt;p&gt;Jekyll中文官方文档 ， 如果你已经安装过了 Jekyll，可以忽略此处。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;配置-bundler-的-gem-源代码镜像命令&quot;&gt;配置 Bundler 的 Gem 源代码镜像命令&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bundle config mirror.https://rubygems.org https://gems.ruby-china.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;获取博客模板&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/kellymao/kellymao.github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者直接下载博客&lt;/p&gt;

&lt;h3 id=&quot;开启本地服务&quot;&gt;开启本地服务&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ jekyll server --host 0.0.0.0 --port 9000  在浏览器输入 127.0.0.1:9000 ， 就可以看到博客效果了。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果有错误：
	gem install bundler
	cd kellymao.github.io
	bundler install&lt;/p&gt;

&lt;h3 id=&quot;配置github-page&quot;&gt;配置github page&lt;/h3&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;https://www.runoob.com/ruby/ruby-installation-unix.html&lt;/p&gt;

&lt;p&gt;https://www.studytime.xin/self-blog/2019/01/20/blog-create-github-jekyll.html&lt;/p&gt;

</description>
        <pubDate>Thu, 29 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:9000/2019/08/jekyll%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/</link>
        <guid isPermaLink="true">http://0.0.0.0:9000/2019/08/jekyll%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%83%A8%E7%BD%B2/</guid>
        
        <category>工具</category>
        
        
      </item>
    
      <item>
        <title>notepad++安装markdown</title>
        <description>&lt;p&gt;　　本篇文章介绍如何在notepad++安装markdown&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文：&lt;/h2&gt;

&lt;h3 id=&quot;导入语言格式文件&quot;&gt;导入语言格式文件&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;到Github下载语言格式文件，下载地址：&lt;a href=&quot;https://github.com/Edditoria/markdown-plus-plus&quot;&gt;markdown-plus-plus&lt;/a&gt;，下载完成后，解压文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;打开Notepad++，点击语言-&amp;gt;自定义语言格式-&amp;gt;导入，选择解压文件中的theme-default\userDefinedLang-markdown.default.modern.xml导入。&lt;/li&gt;
  &lt;li&gt;重启Notepad++，点击语言菜单中出现Markdown选项，操作成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;预览插件&quot;&gt;预览插件&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;到Github下载预览插件，下载地址：&lt;a href=&quot;https://github.com/nea/MarkdownViewerPlusPlus/releases&quot;&gt;MarkdownViewerPlusPlus&lt;/a&gt;,下载完成后，解压文件。&lt;/li&gt;
  &lt;li&gt;打开Notepad++，点击设置-&amp;gt;导入-&amp;gt;导入插件，选择解压文件中的MarkdownViewerPlusPlus-0.8.2-x64\MarkdownViewerPlusPlus.dll导入。&lt;/li&gt;
  &lt;li&gt;重启Notepad++，工具栏出现Markdown图片，点击打开，操作成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考链接: &lt;a href=&quot;https://my.oschina.net/u/2424727/blog/1921658&quot;&gt;markdown安装&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:9000/2019/08/Notepad++%E5%AE%89%E8%A3%85Markdown/</link>
        <guid isPermaLink="true">http://0.0.0.0:9000/2019/08/Notepad++%E5%AE%89%E8%A3%85Markdown/</guid>
        
        <category>工具</category>
        
        
      </item>
    
  </channel>
</rss>
